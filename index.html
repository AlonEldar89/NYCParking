<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cardboard Teacher Parking Finder</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.2/proj4.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0f1117; color: #e4e4e7; }
  #map { width: 100%; height: 60vh; }
  .header { padding: 16px 24px; background: #18181b; border-bottom: 1px solid #27272a; display: flex; align-items: center; gap: 16px; }
  .header h1 { font-size: 1.25rem; font-weight: 600; }
  .header .hint { font-size: 0.8rem; color: #71717a; }
  #status { padding: 8px 24px; font-size: 0.8rem; color: #a1a1aa; background: #18181b; }
  #results { padding: 12px 24px; max-height: 35vh; overflow-y: auto; }
  .card { background: #1e1e24; border: 1px solid #27272a; border-radius: 10px; padding: 14px 18px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; transition: border-color 0.15s; }
  .card:hover { border-color: #4ade80; }
  .card .street { font-weight: 600; font-size: 0.95rem; }
  .card .detail { font-size: 0.78rem; color: #a1a1aa; margin-top: 2px; }
  .badge { font-size: 0.85rem; font-weight: 700; padding: 6px 14px; border-radius: 20px; white-space: nowrap; }
  .badge.d5 { background: #064e3b; color: #6ee7b7; }
  .badge.d4 { background: #065f46; color: #86efac; }
  .badge.d3 { background: #854d0e; color: #fde68a; }
  .badge.d2 { background: #92400e; color: #fed7aa; }
  .badge.d1 { background: #9a3412; color: #fdba74; }
  .badge.d0 { background: #7f1d1d; color: #fca5a5; }
  .loading { text-align: center; padding: 40px; color: #71717a; }
  .legend { position: absolute; bottom: 24px; right: 24px; background: #18181bee; border: 1px solid #27272a; border-radius: 10px; padding: 12px 16px; z-index: 1000; font-size: 0.78rem; }
  .legend-title { font-weight: 600; margin-bottom: 8px; font-size: 0.82rem; }
  .legend-row { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
  .legend-line { width: 28px; height: 5px; border-radius: 3px; }
</style>
</head>
<body>
<div class="header">
  <h1>Cardboard Teacher Parking Finder</h1>
  <span class="hint">Click anywhere on the map to find streets with the most time until the next street cleaning</span>
</div>
<div id="map">
  <div class="legend">
    <div class="legend-title">Time until cleaning</div>
    <div class="legend-row"><div class="legend-line" style="background:#22c55e"></div> 5+ days</div>
    <div class="legend-row"><div class="legend-line" style="background:#4ade80"></div> 4 days</div>
    <div class="legend-row"><div class="legend-line" style="background:#eab308"></div> 3 days</div>
    <div class="legend-row"><div class="legend-line" style="background:#f59e0b"></div> 2 days</div>
    <div class="legend-row"><div class="legend-line" style="background:#f97316"></div> 1 day</div>
    <div class="legend-row"><div class="legend-line" style="background:#ef4444"></div> &lt; 1 day</div>
  </div>
</div>
<div id="status"></div>
<div id="results"><div class="loading">Click on the map to get started</div></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>

// --- Coordinate conversion (EPSG:2263 NY State Plane ft -> WGS84) ---
proj4.defs('EPSG:2263', '+proj=lcc +lat_1=41.03333333333333 +lat_2=40.66666666666666 +lat_0=40.16666666666666 +lon_0=-74 +x_0=300000 +y_0=0 +ellps=GRS80 +units=us-ft +no_defs');

function toLatLng(x, y) {
  const [lng, lat] = proj4('EPSG:2263', 'EPSG:4326', [x, y]);
  return { lat, lng };
}

// --- Sign description parser ---
const DAYS = { MONDAY: 0, TUESDAY: 1, WEDNESDAY: 2, THURSDAY: 3, FRIDAY: 4, SATURDAY: 5, SUNDAY: 6 };
const DAY_RE = /\b(MONDAY|TUESDAY|WEDNESDAY|THURSDAY|FRIDAY|SATURDAY|SUNDAY)\b/gi;
const TIME_RE = /(\d{1,2}(?::\d{2})?(?:AM|PM))\s*-\s*(\d{1,2}(?::\d{2})?(?:AM|PM))/i;
const EXCEPT_RE = /EXCEPT\s+(MONDAY|TUESDAY|WEDNESDAY|THURSDAY|FRIDAY|SATURDAY|SUNDAY)/gi;

function parseTime(t) {
  t = t.toUpperCase();
  const isPM = t.includes('PM');
  t = t.replace(/[AP]M/, '');
  let [h, m] = t.includes(':') ? t.split(':').map(Number) : [Number(t), 0];
  if (isPM && h !== 12) h += 12;
  if (!isPM && h === 12) h = 0;
  return { h, m };
}

function parseSign(desc) {
  const upper = desc.toUpperCase();
  if (!upper.includes('SANITATION BROOM SYMBOL')) return null;

  const exceptDays = new Set();
  let em;
  while ((em = EXCEPT_RE.exec(upper))) exceptDays.add(DAYS[em[1]]);
  EXCEPT_RE.lastIndex = 0;

  const cleaned = upper.replace(/EXCEPT\s+\w+/g, '');
  const dayMatches = [...cleaned.matchAll(DAY_RE)].map(m => DAYS[m[1].toUpperCase()]);
  DAY_RE.lastIndex = 0;

  let days;
  if (dayMatches.length > 0) {
    days = [...new Set(dayMatches)].filter(d => !exceptDays.has(d)).sort();
  } else if (exceptDays.size > 0) {
    days = [0,1,2,3,4,5,6].filter(d => !exceptDays.has(d));
  } else {
    return null;
  }
  if (days.length === 0) return null;

  const tm = TIME_RE.exec(desc);
  if (!tm) return null;
  const start = parseTime(tm[1]);
  const end = parseTime(tm[2]);

  return { days, startH: start.h, startM: start.m, endH: end.h, endM: end.m };
}

// --- Hours until next cleaning ---
function hoursUntilCleaning(schedule) {
  const now = new Date(new Date().toLocaleString('en-US', { timeZone: 'America/New_York' }));
  const curDay = now.getDay() === 0 ? 6 : now.getDay() - 1; // JS Sun=0 -> Mon=0
  const curMin = now.getHours() * 60 + now.getMinutes();
  const startMin = schedule.startH * 60 + schedule.startM;
  const endMin = schedule.endH * 60 + schedule.endM;

  for (let offset = 0; offset < 8; offset++) {
    const checkDay = (curDay + offset) % 7;
    if (!schedule.days.includes(checkDay)) continue;
    if (offset === 0) {
      if (curMin >= startMin && curMin < endMin) return 0;
      if (curMin < startMin) return (startMin - curMin) / 60;
      continue;
    }
    return (offset * 24 * 60 + startMin - curMin) / 60;
  }
  return 999;
}

// --- Haversine ---
function haversineKm(lat1, lng1, lat2, lng2) {
  const R = 6371, toRad = Math.PI / 180;
  const dLat = (lat2 - lat1) * toRad, dLng = (lng2 - lng1) * toRad;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*toRad) * Math.cos(lat2*toRad) * Math.sin(dLng/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

// --- SODA API fetch with pagination ---
const SODA_URL = 'https://data.cityofnewyork.us/resource/nfid-uabd.json';
const PAGE = 50000;
let signCache = null;

async function fetchAllSigns(statusEl) {
  if (signCache) return signCache;
  const signs = [];
  let offset = 0;
  while (true) {
    statusEl.textContent = `Loading sign data... (${signs.length} so far)`;
    const url = `${SODA_URL}?$where=sign_description like '%25SANITATION BROOM SYMBOL%25'` +
      `&$select=on_street,from_street,to_street,side_of_street,borough,sign_description,sign_x_coord,sign_y_coord` +
      `&$order=:id&$limit=${PAGE}&$offset=${offset}`;
    const resp = await fetch(url);
    const page = await resp.json();
    if (!page.length) break;

    for (const row of page) {
      if (!row.sign_x_coord || !row.sign_y_coord) continue;
      const schedule = parseSign(row.sign_description || '');
      if (!schedule) continue;
      const { lat, lng } = toLatLng(parseFloat(row.sign_x_coord), parseFloat(row.sign_y_coord));
      signs.push({
        on_street: row.on_street || '', from_street: row.from_street || '',
        to_street: row.to_street || '', side: row.side_of_street || '',
        borough: row.borough || '', description: row.sign_description || '',
        lat, lng, schedule,
      });
    }
    if (page.length < PAGE) break;
    offset += PAGE;
  }
  signCache = signs;
  return signs;
}

// --- UI ---
const TIERS = [
  { min: 120, color: '#22c55e', badge: 'd5' },
  { min:  96, color: '#4ade80', badge: 'd4' },
  { min:  72, color: '#eab308', badge: 'd3' },
  { min:  48, color: '#f59e0b', badge: 'd2' },
  { min:  24, color: '#f97316', badge: 'd1' },
  { min:   0, color: '#ef4444', badge: 'd0' },
];
function getTier(hours) { return TIERS.find(t => hours >= t.min) || TIERS[TIERS.length - 1]; }

function formatHours(h) {
  if (h === 0) return 'NOW';
  if (h < 1) return Math.round(h * 60) + 'm';
  if (h < 24) return Math.round(h) + 'h';
  const d = Math.floor(h / 24), rem = Math.round(h % 24);
  return d + 'd ' + rem + 'h';
}

const map = L.map('map').setView([40.6390, -73.9686], 16);
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; OpenStreetMap &copy; CARTO', maxZoom: 19,
}).addTo(map);

let layerGroup = L.layerGroup().addTo(map);
let clickMarker = null;
const HOME = [40.6390, -73.9686];
const WALK_7MIN_KM = 0.56;

async function search(lat, lng) {
  const status = document.getElementById('status');
  const results = document.getElementById('results');
  results.innerHTML = '<div class="loading">Loading...</div>';

  try {
    const signs = await fetchAllSigns(status);
    status.textContent = 'Finding nearby segments...';

    const segments = {};
    for (const s of signs) {
      if (haversineKm(lat, lng, s.lat, s.lng) > WALK_7MIN_KM) continue;
      const key = `${s.on_street}|${s.from_street}|${s.to_street}|${s.side}`;
      if (!segments[key]) {
        const hrs = hoursUntilCleaning(s.schedule);
        segments[key] = { ...s, hours: Math.round(hrs * 10) / 10, coords: [] };
      }
      segments[key].coords.push([s.lat, s.lng]);
    }

    const data = Object.values(segments).map(seg => {
      const coords = seg.coords.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
      return { ...seg, start: coords[0], end: coords[coords.length - 1] };
    }).sort((a, b) => b.hours - a.hours);

    status.textContent = `Found ${data.length} street segments nearby`;
    layerGroup.clearLayers();
    results.innerHTML = '';

    if (!data.length) {
      results.innerHTML = '<div class="loading">No street cleaning signs found in this area. Try clicking elsewhere.</div>';
      return;
    }

    for (const s of data) {
      const tier = getTier(s.hours);
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `
        <div>
          <div class="street">${s.on_street}</div>
          <div class="detail">${s.from_street} to ${s.to_street} &middot; ${s.side} side &middot; ${s.borough}</div>
          <div class="detail">${s.description.replace('(SANITATION BROOM SYMBOL) ', '')}</div>
        </div>
        <div class="badge ${tier.badge}">${formatHours(s.hours)}</div>`;
      const midLat = (s.start[0] + s.end[0]) / 2, midLng = (s.start[1] + s.end[1]) / 2;
      card.addEventListener('click', () => map.flyTo([midLat, midLng], 17));
      results.appendChild(card);

      const line = L.polyline([s.start, s.end], { color: tier.color, weight: 6, opacity: 0.85, lineCap: 'round' });
      line.bindPopup(`<b>${s.on_street}</b><br>${s.from_street} â†’ ${s.to_street}<br>${formatHours(s.hours)} until cleaning`);
      layerGroup.addLayer(line);
    }
  } catch (err) {
    status.textContent = 'Error loading data';
    results.innerHTML = `<div class="loading">${err.message}</div>`;
  }
}

map.on('click', (e) => {
  if (clickMarker) map.removeLayer(clickMarker);
  clickMarker = L.marker([e.latlng.lat, e.latlng.lng]).addTo(map);
  search(e.latlng.lat, e.latlng.lng);
});

search(HOME[0], HOME[1]);
</script>
</body>
</html>
